#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "portaudio.h"
#include "datatype.h"
#include "opt.h"
#include "misc.h"
#include "pa-misc.h"
#include "chansel.h"
#include "imatrix.h"
#include "fmatrix.h"
#include "chansel.h"
#include "sndfile.h"
#include "setopt.h"
#include <time.h>

int main(int ac, char** av)
{
	PaError err = Pa_Initialize();
	if( err != paNoError )
	  return pa_prError(err, "Initialize");
	pa_showDev();

	/*変数の宣言*/
	double N ;
	int i = 0;
	double f;
	double A;
	double s;
	double fs;
	char *name;
	int channel;
	int cnt = 0; //While内で用いるカウント
	int pts;
	int j;
	double gauss = 0; //正規乱数
	double uniform = 0; //一様乱数
	int white; //ホワイトノイズかサイン波を判定する用のフラグ
	
	  
       

	/*引数に値を入力*/
	Opt* op = opt_open(ac, av, av[0]);
	char* dev = opt_char(op, "-d", "default", "再生デバイス");
	int blk = opt_int(op, "-b", 64, "バッファ長");

	/*ptsにblkを代入*/
	pts = blk;


	/*ファイル入力*/
	char* ifile = opt_char(op, "-i", NULL, "入力ファイル");
	//if(!ifile) errExit("入力ファイルが指定されていません。\n");

	/*ホワイトノイズの判定入力*/
	white = opt_int(op, "-wh", 0, "ホワイトノイズ");


	/*フラグ（ファイル入力とホワイトノイズ判定がなかった場合）*/
	if(ifile == NULL && white == 0){
	  
	  
	  f = opt_double(op, "-f", 1000.0, "周波数");
	  A = opt_double(op, "-A", 0.2, "振幅");
	  fs = opt_double(op, "-fs", 48000, "サンプリング周波数");
	  s = opt_double(op, "-s", 10, "秒数");
	  name = opt_char(op, "-n", "sampling.wav", "音声ファイル名");
	  channel = opt_int(op, "-ch", 1, "チャンネル数");

	 
	  N = s * fs; //サンプリング個数をNに代入
	  
	}/*ホワイトノイズの時*/
	else if(ifile == NULL && white == 1 ){ 
	  channel = opt_int(op, "-ch", 1, "チャンネル数");
	  name = opt_char(op, "-n", "whitenoise.wav","音声ファイル名");
	  s = opt_double(op, "-s", 10, "秒数");
	  fs = opt_double(op, "-fs", 48000, "サンプリング周波数");
	  A = opt_double(op, "-A", 0.2, "振幅");
	  N = fs * s;
	}
	

	SF_INFO si;
	SNDFILE* fpi;
	if(ifile == NULL){
	  si.channels = channel;
	  si.samplerate = fs;
	}else{
	  fpi = sf_open(ifile, SFM_READ, &si);
	  if(!fpi) errExit("入力サンドファイル オープン失敗。\n");
	}
	  
	  
	

	
#ifdef PAFLOAT
	PaSampleFormat pafmt = paFloat32;
	float* ixx = fm_1D_create(blk*si.channels);
	float* iyy = fm_1D_create(blk*si.channels);
#else
	PaSampleFormat pafmt = paInt32;
	int* ixx = im_1D_create(blk*si.channels);
	int* iyy = im_1D_create(blk*si.channels);
#endif

	ChanSel* csl = chansel_open(op, si.channels, "-co", si.channels);  // 再生デバイスに送るチャネル設定
	PaStream *stream = pa_openSimplex(pa_dev2idx(dev), 'w', si.samplerate, chansel_ncho(csl), blk, pafmt);
	err = Pa_StartStream(stream);
	if( err != paNoError ) pa_prError(err, "Start Stream");
	opt_pr(op);


	/*ホワイトノイズの記述*/
	srand((unsigned int)time(NULL)); //初期値をタイムを用いてランダムにする
	while(1){
	  
	  
#ifdef PAFLOAT
	  if(ifile == NULL && white == 0){
	    for(i = 0; i < blk; i++){
	      ixx[i] =  A*sin(2*M_PI*f*(i/fs + (blk * cnt/fs)));
	    }
	  }else if(ifile == NULL && white == 1){
	    
	    
	    for(i=0;i<blk;i++){
	      for(j = 0; j < 12; j++){
		uniform = (double)rand() / (double)(RAND_MAX); //一様乱数を生成
		gauss = gauss + uniform; //足しこみ
	      }
	      gauss = gauss - 6;
	      //if(gauss <-1.0 || 1.0<gauss){i--; continue;}
	      ixx[i] = (float)(A * gauss);
	      gauss = 0; //正規乱数の初期化
	    }
	    
	  }else{
	    pts = sf_readf_float(fpi, ixx, blk);
	  }
	  
#else
	  if(ifile == NULL && white == 0){
	    for(i = 0; i < blk; i++){
	      ixx[i] =  A*sin(2*M_PI*f*(i/fs + (blk * cnt/fs)));
	    }
	  }else if(ifile == NULL && white == 1){
	    
	    for(i=0;i<blk;i++){
	      for(j = 0; j < 12; j++){
		uniform = (double)rand() / (double)(RAND_MAX); //一様乱数を生成
		gauss = gauss + uniform; //足しこみ
	      }
	      gauss = gauss - 6;
	      // if(gauss <-1.0 || 1.0<gauss){i--; continue;}
	      ixx[i] = (int)(A * gauss);
	      gauss = 0; //正規乱数の初期化
	      uniform = 0; //一様乱数の初期化
	    }
	  }else{
	    pts = sf_readf_float(fpi, ixx, blk);
	  }
	    
	  
	    
	  
#endif
	    chansel_exec(csl, (char*)ixx, (char*)iyy, pa_sampleSize(pafmt), pts);
	    
	    if((err = Pa_WriteStream(stream, iyy, pts)) != paNoError) pa_prError(err, "Write Stream");
	    
	    if(ifile == NULL){
	      cnt ++;
	    if(blk * cnt > N ) break;
	    }else{
	      if(pts != blk) break;
	    }
	}
	
	  if((err = Pa_StopStream(stream)) != paNoError) pa_prError(err, "Stop Stream");
	  
	  Pa_CloseStream(stream);
	  Pa_Terminate();
	  opt_close(op);
	  sf_close(fpi);
#ifdef PAFLOAT
	  fm_1D_free(ixx);
	  fm_1D_free(iyy);
#else
	  im_1D_free(ixx);
	  im_1D_free(iyy);
#endif
	  return 0;
}
